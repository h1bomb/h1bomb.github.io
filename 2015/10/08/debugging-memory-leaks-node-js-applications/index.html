<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>uupup！ › 调试node.js应用的内存泄漏[译]</title>
  <meta name="author" content="H1bomb">
  
  <meta name="description" content="原文：http://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications
有一次，我开着一辆内部是V8双涡轮增压发动机的奥迪，其性能令人难以置信。凌晨3点，我行驶在芝加哥附近没有人的IL-80高速公路，时速达到140MPH">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="调试node.js应用的内存泄漏[译]"/>
  <meta property="og:site_name" content="uupup！"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="uupup！" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-63097959-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">uupup！</a></h1>
  <h2><a href="/"></a></h2>
  <nav id="main-nav">
    <ul>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">调试node.js应用的内存泄漏[译]</h1>
  

      
      <time datetime="2015-10-08T00:51:07.000Z">Oct 8 2015</time>
      
    </header>
    <div class="entry">
      
        <p>原文：<a href="http://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" target="_blank" rel="external">http://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications</a></p>
<p>有一次，我开着一辆内部是V8双涡轮增压发动机的奥迪，其性能令人难以置信。凌晨3点，我行驶在芝加哥附近没有人的IL-80高速公路，时速达到140MPH。从那时起，“V8”这个术语成为我对高性能的认识。</p>
<blockquote>
<p>Node.js是一个建立在Chrome的JavaScript引擎V8之上的易于快速构建可伸缩的网络应用的平台。</p>
</blockquote>
<p>尽管奥迪的V8非常强大，但仍然限于用你的油箱的容量大小。这同样适用于谷歌的V8引擎 - 在node.js背后的JavaScript引擎。有很多因素使Node.js的性能是难以置信的，<a href="http://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js" target="_blank" rel="external">适用于许多应用案例</a>，但是你总是受限于内存堆的大小。当你的Node.js应用程序需要处理更多的请求时，你有两个选择：就是规模垂直或水平扩展。水平扩展意味着你必须运行多个并发的应用程序实例。如果做得对，你最终能够服务更多的请求。垂直扩展意味着你要为你的应用实例提高应用程序的内存使用情况和可用的性能或增加资源。</p>
<p><img src="http://assets.toptal.io/uploads/blog/image/91676/toptal-blog-image-1442927311924-3c41bb7d7b1a8306609bcbe5570ccc63.jpg" alt="http://assets.toptal.io/uploads/blog/image/91676/toptal-blog-image-1442927311924-3c41bb7d7b1a8306609bcbe5570ccc63.jpg"></p>
<p>最近有为我的Toptal（一个开放外包的平台）客户修复一个运行在Node.js上应用程序的内存泄漏问题。该应用程序是一个能够在每一分钟处理成千上万请求的API服务器。最初的应用几乎占据了600MB的RAM，所以我们决定采取热API端来重新实现它们。当你需要服务于许多请求开销变得非常昂贵。</p>
<p>对于新的API，我们选择的restify以及本地的MongoDB的驱动程序和Kue后台服务。听起来像是一个非常轻量级的栈，对不对？其实不然。在高峰负荷新的应用程序实例可以消耗高达270MB的RAM。因此起两个每1X的Heroku Dyno应用实的想法破灭了。</p>
<h2 id="Node-js_内存泄露调试军火库">Node.js 内存泄露调试军火库</h2>
<h3 id="Memwatch">Memwatch</h3>
<p>如果你搜索“如何在node里发现泄露”这个第一个你或许会搜到的工具就是memwatch。原始的包很久以前就被遗弃，不再保留。但是你可以很容易地找到在GitHub上的fork的库的更新版本。该模块是有用的，如果它看到堆增长超过5个连续的垃圾收集，它可以触发泄漏事件。</p>
<h3 id="Heapdump">Heapdump</h3>
<p>伟大的工具，它允许开发人员使用Chrome开发人员工具对Node.js采取堆快照后对其进行检查。</p>
<h3 id="Node-inspector">Node-inspector</h3>
<p>即使是被更为有用的heapdump替代，但它任然可以让你连接到运行的应用程序，采取堆转储，甚至调试，并重新编译在程序运行中。</p>
<h2 id="针对“node-inspector”_的说明">针对“node-inspector” 的说明</h2>
<p>不幸的是，将不能连接到被在Heroku运行生产的应用中，因为不允许信号被发送到运行的进程。然而，Heroku的是不是唯一的托管平台。</p>
<p>为了在实战中体验node-inspector，我们将使用的RESTify编写一个简单的Node.js应用程序并将一点点内存泄漏的根源放在其中。这里所有的实验都是用Node.js v0.12.7和已编译的V8 v3.28.71.19。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> restify = <span class="built_in">require</span>(<span class="string">'restify'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = restify.createServer();</div><div class="line"></div><div class="line"><span class="keyword">var</span> tasks = [];</div><div class="line"></div><div class="line">server.pre(<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>{</div><div class="line">  tasks.push(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> req.headers;</div><div class="line">  });</div><div class="line"></div><div class="line">  <span class="comment">// Synchronously get user from session, maybe jwt token</span></div><div class="line">  req.user = {</div><div class="line">    id: <span class="number">1</span>,</div><div class="line">    username: <span class="string">'Leaky Master'</span>,</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">return</span> next();</div><div class="line">});</div><div class="line"></div><div class="line">server.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>{</div><div class="line">  res.send(<span class="string">'Hi '</span> + req.user.username);</div><div class="line">  <span class="keyword">return</span> next();</div><div class="line">});</div><div class="line"></div><div class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'%s listening at %s'</span>, server.name, server.url);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>这个应用有个很简单且明显的内存泄漏。这个tasks的数组在应用的生命周期内引发变慢，并最终导致崩溃。这个问题是，不仅仅是闭包泄漏，而是波及了整个请求对象。</p>
<p>GC in V8 employs stop-the-world strategy, therefore it means more objects you have in memory the longer it will take to collect garbage. On log below you can clearly see that in the beginning of the application life it would take an average of 20ms to collect the garbage, but few hundred thousand requests later it takes around 230ms. People who are trying to access our application would have to wait 230ms longer now because of GC. Also you can see that GC is invoked every few seconds which means that every few seconds users would experience problems accessing our application. And delay will grow up until application crashes.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[<span class="number">28093</span>]     <span class="number">7644</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">10.9</span> <span class="function"><span class="params">(<span class="number">48.5</span>)</span> -&gt;</span> <span class="number">10.9</span> (<span class="number">48.5</span>) MB, <span class="number">25.0</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div><div class="line"></div><div class="line">[<span class="number">28093</span>]     <span class="number">7717</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">10.9</span> <span class="function"><span class="params">(<span class="number">48.5</span>)</span> -&gt;</span> <span class="number">10.9</span> (<span class="number">48.5</span>) MB, <span class="number">18.0</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div><div class="line"></div><div class="line">[<span class="number">28093</span>]     <span class="number">7866</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">11.0</span> <span class="function"><span class="params">(<span class="number">48.5</span>)</span> -&gt;</span> <span class="number">10.9</span> (<span class="number">48.5</span>) MB, <span class="number">23.2</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div><div class="line"></div><div class="line">[<span class="number">28093</span>]     <span class="number">8001</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">11.0</span> <span class="function"><span class="params">(<span class="number">48.5</span>)</span> -&gt;</span> <span class="number">10.9</span> (<span class="number">48.5</span>) MB, <span class="number">18.4</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">[<span class="number">28093</span>]   <span class="number">633891</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">235.7</span> <span class="function"><span class="params">(<span class="number">290.5</span>)</span> -&gt;</span> <span class="number">235.7</span> (<span class="number">290.5</span>) MB, <span class="number">357.3</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div><div class="line"></div><div class="line">[<span class="number">28093</span>]   <span class="number">635672</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">235.7</span> <span class="function"><span class="params">(<span class="number">290.5</span>)</span> -&gt;</span> <span class="number">235.7</span> (<span class="number">290.5</span>) MB, <span class="number">331.5</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div><div class="line"></div><div class="line">[<span class="number">28093</span>]   <span class="number">637508</span> <span class="attribute">ms</span>: Mark-sweep <span class="number">235.7</span> <span class="function"><span class="params">(<span class="number">290.5</span>)</span> -&gt;</span> <span class="number">235.7</span> (<span class="number">290.5</span>) MB, <span class="number">357.2</span> ms [<span class="attribute">HeapObjectsMap</span>::UpdateHeapObjectsMap] [GC <span class="keyword">in</span> old space requested].</div></pre></td></tr></table></figure>

<p>These log lines are printed when a Node.js application is started with the –trace_gc flag:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">node</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">trace_gc</span> <span class="comment">app</span><span class="string">.</span><span class="comment">js</span></div></pre></td></tr></table></figure>

<p>Let us assume that we have already started our Node.js application with this flag. Before connecting the application with node-inspector, we need to send it the SIGUSR1 signal to the running process. If you run Node.js in cluster, make sure you connect to one of the slave processes.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">kill</span> -SIGUSR1 <span class="variable">$pid</span> <span class="comment"># Replace $pid with the actual process ID</span></div></pre></td></tr></table></figure>

<p>By doing this, we are making the Node.js application (V8 to be precise) enter debugging mode. In this mode, the application automatically opens the port 5858 with <a href="https://code.google.com/p/v8-wiki/wiki/DebuggerProtocol" target="_blank" rel="external">V8 Debugging Protocol</a>.</p>
<p>Our next step is to run node-inspector which will connect to the debugging interface of the running application and open another web interface on port 8080.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>node-inspector</div><div class="line"><span class="constant">Node</span> <span class="constant">Inspector</span> v<span class="number">0</span>.<span class="number">12.2</span></div><div class="line"><span class="constant">Visit</span> <span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:8080/</span>?ws=<span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span><span class="symbol">:</span><span class="number">8080</span>&port=<span class="number">5858</span> to start debugging.</div></pre></td></tr></table></figure>

<p>In case the application is running on production and you have a firewall in place, we can tunnel remote port 8080 to localhost:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">ssh</span> <span class="tag">-L</span> 8080<span class="pseudo">:localhost</span><span class="pseudo">:8080</span> <span class="tag">admin</span><span class="at_rule">@<span class="keyword">example.com</span></span></div></pre></td></tr></table></figure>

<p>Now you could open your Chrome web browser and get full access to Chrome Development Tools attached to your remote production application. Unfortunately, Chrome Developer Tools will not work in other browsers.</p>
<h2 id="Let’s_Find_a_Leak!">Let’s Find a Leak!</h2>
<p>Memory leaks in V8 are not real memory leaks as we know them from C/C++ applications. In JavaScript variables do not disappear into the void, they just get “forgotten”. Our goal is to find these forgotten variables and remind them that Dobby is free.</p>
<p>Inside Chrome Developer Tools we have access to multiple profilers. We are particularly interested in Record Heap Allocations which runs and takes multiple heap snapshots over time. This gives us a clear peek into which objects are leaking.</p>
<p>Start recording heap allocations and let’s simulate 50 concurrent users on our home page using Apache Benchmark.</p>
<p><img src="http://assets.toptal.io/uploads/blog/image/91677/toptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg" alt="http://assets.toptal.io/uploads/blog/image/91677/toptal-blog-image-1442927477717.3-7c74dfceddd0955f27de9129eedf4261.jpg"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab -<span class="built_in">c</span> <span class="number">50</span> -n <span class="number">1000000</span> -k http:<span class="comment">//example.com/</span></div></pre></td></tr></table></figure>

<p>Before taking new snapshots, V8 would perform mark-sweep garbage collection, so we definitely know that there is no old garbage in the snapshot.</p>
<h2 id="Fixing_the_Leak_on_the_Fly">Fixing the Leak on the Fly</h2>
<p>After collecting heap allocation snapshots over a period of 3 minutes we end up with something like the following:</p>
<p><img src="http://assets.toptal.io/uploads/blog/image/91678/toptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg" alt="http://assets.toptal.io/uploads/blog/image/91678/toptal-blog-image-1442927547865.5-d0c4450569bc2a285b3007eca57dfa25.jpg"></p>
<p>We can clearly see that there are some gigantic arrays, a lot of IncomingMessage, ReadableState, ServerResponse and Domain objects as well in heap. Let’s try to analyze the source of the leak.</p>
<p>Upon selecting heap diff on chart from 20s to 40s, we will only see objects which were added after 20s from when you started the profiler. This way you could exclude all normal data.</p>
<p>Keeping note of how many objects of each type are in the system, we expand the filter from 20s to 1min. We can see that the arrays, already quite gigantic, keeps growing. Under “(array)” we can see that there are a lot of objects “(object properties)” with equal distance. Those objects are the source of our memory leak.</p>
<p>Also we can see that “(closure)” objects grow rapidly as well.</p>
<p>It might be handy to look at the strings as well. Under the strings list there are a lot of “Hi Leaky Master” phrases. Those might give us some clue too.</p>
<p>In our case we know that the string ”Hi Leaky Master” could only be assembled under the “GET /” route.</p>
<p>If you open retainers path you will see this string is somehow referenced via req, then there is context created and all this added to some giant array of closures.</p>
<p><img src="http://assets.toptal.io/uploads/blog/image/91679/toptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg" alt="http://assets.toptal.io/uploads/blog/image/91679/toptal-blog-image-1442927578118.2-af56af07dcf63ead26df3f9b9cd1aa78.jpg"></p>
<p>So at this point we know that we have some kind of gigantic array of closures. Let’s actually go and give a name to all our closures at real-time under sources tab.</p>
<p><img src="http://assets.toptal.io/uploads/blog/image/91680/toptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg" alt="http://assets.toptal.io/uploads/blog/image/91680/toptal-blog-image-1442927612747.1-102c5cf7bb68bcfc12181ab69333a520.jpg"></p>
<p>After we are done editing the code, we can hit CTRL+S to save and recompile code on the fly!</p>
<p>Now let’s record another Heap Allocations Snapshot and see which closures are occupying the memory.</p>
<p>It’s clear that SomeKindOfClojure() is our villain. Now we can see that SomeKindOfClojure() closures are being added to some array named tasks in the global space.</p>
<p>It’s easy to see that this array is just useless. We can comment it out. But how do we free memory the memory already occupied? Very easy, we just assign an empty array to tasks and with the next request it will be overridden and memory will be freed after next GC event.</p>
<p><img src="http://assets.toptal.io/uploads/blog/image/91681/toptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg" alt="http://assets.toptal.io/uploads/blog/image/91681/toptal-blog-image-1442927629279.4-24b223edd5e9b530625bd595fc50c4d1.jpg"></p>
<p>Dobby is free!</p>
<h2 id="Life_of_Garbage_in_V8">Life of Garbage in V8</h2>
<p><img src="http://assets.toptal.io/uploads/blog/image/91682/toptal-blog-image-1442928276284-e3da8ab85a898674f8f39088768b617a.jpg" alt="http://assets.toptal.io/uploads/blog/image/91682/toptal-blog-image-1442928276284-e3da8ab85a898674f8f39088768b617a.jpg"></p>
<p>Well, V8 JS does not have memory leaks, only forgotten variables.</p>
<p>V8 heap is divided into several different spaces:</p>
<p>New Space: This space is relatively small and has a size of between 1MB and 8MB. Most of the objects are allocated here.</p>
<ul>
<li>Old Pointer Space: Has objects which may have pointers to other objects. If object survives long enough in New Space it gets promoted to Old Pointer Space.</li>
<li>Old Data Space: Contains only raw data like strings, boxed numbers and arrays of unboxed doubles. Objects that have survived GC in the New Space for long enough are moved here as well.</li>
<li>Large Object Space: Objects which are too big to fit in other spaces are created in this space. Each object has it’s own mmap‘ed region in memory</li>
<li>Code space: Contains assembly code generated by the JIT compiler.</li>
<li>Cell space, property cell space, map space: This space contains Cells, PropertyCells, and Maps. This is used to simplify garbage collection.</li>
</ul>
<p>Each space is composed of pages. A page is a region of memory allocated from the operating system with mmap. Each page is always 1MB in size except for pages in large object space.</p>
<p>V8 has two built in garbage collection mechanisms: Scavenge, Mark-Sweep and Mark-Compact.</p>
<p>Scavenge is a very fast garbage collection technique and operates with objects in New Space. Scavenge is the implementation of <a href="http://en.wikipedia.org/wiki/Cheney&#39;s_algorithm" target="_blank" rel="external">Cheney’s Algorithm</a>. The idea is very simple, New Space is divided in two equal semi-spaces: To-Space and From-Space. Scavenge GC occurs when To-Space is full. It simply swaps To and From spaces and copy all live objects to To-Space or promote them to one of the old spaces if they survived two scavenges, and is then entirely erased from the space. Scavenges are very fast however they have the overhead of keeping double sized heap and constantly copying objects in memory. The reason to use scavenges is because most objects die young.</p>
<p>Mark-Sweep &amp; Mark-Compact is another type of garbage collector used in V8. The other name is full garbage collector. It marks all live nodes, then sweeps all dead nodes and defragments memory.</p>
<h3 id="GC_Performance_and_Debugging_Tips">GC Performance and Debugging Tips</h3>
<p>While for web applications high performance might not be such a big problem, you will still want to avoid leaks at all costs. During the mark phase in full GC the application is actually paused until garbage collection is completed. This means the more objects you have in the heap, the longer it will take to perform GC and the longer users will have to wait.</p>
<h3 id="Always_give_names_to_closures_and_functions">Always give names to closures and functions</h3>
<p>It’s much easier to inspect stack traces and heaps when all your closures and functions have names.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.query(<span class="string">'GIVE THEM ALL'</span>, <span class="function"><span class="keyword">function</span> <span class="title">GiveThemAllAName</span><span class="params">(error, data)</span> </span>{</div><div class="line">    ...</div><div class="line">})</div></pre></td></tr></table></figure>

<h3 id="Avoid_large_objects_in_hot_functions">Avoid large objects in hot functions</h3>
<p>Ideally you want to avoid large objects inside of hot functions so that all data is fit into New Space. All CPU and memory bound operations should be executed in background. Also avoid deoptimization triggers for hot functions, optimized hot function uses less memory than non-optimized ones.</p>
<h3 id="Hot_functions_should_be_optimized">Hot functions should be optimized</h3>
<p>Hot functions that run faster but also consume less memory cause GC to run less often. V8 provides some helpful debugging tools to spot non-optimized functions or deoptimized functions.</p>
<p>Avoid polymorphism for IC’s in hot functions</p>
<p>Inline Caches (IC) are used to speed up execution of some chunks of code, either by caching object property access obj.key or some simple function.</p>
<figure class="highlight javscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span><span class="params">(a, b)</span> <span class="comment">{</span></span></div><div class="line">  return a + b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="title">x</span><span class="params">(1, 2)</span>; <span class="comment">// monomorphic</span></div><div class="line">x(<span class="number">1</span>, “<span class="keyword">string</span>”); <span class="comment">// polymorphic, level 2</span></div><div class="line">x(<span class="number">3.14</span>, <span class="number">1</span>); <span class="comment">// polymorphic, level 3</span></div></pre></td></tr></table></figure>

<p>When <code>x(a,b)</code> is run for the first time, V8 creates a monomorphic IC. When you call x a second time, V8 erases the old IC and creates a new polymorphic IC which supports both types of operands integer and string. When you call IC the third time, V8 repeats the same procedure and creates another polymorphic IC of level 3.</p>
<p>However, there is a limitation. After IC level reaches 5 (could be changed with <code>–max_inlining_levels</code> flag) the function becomes megamorphic and is no longer considered optimizable.</p>
<p>It’s intuitively understandable that monomorphic functions run the fastest and also have a smaller memory footprint.</p>
<h3 id="Don’t_add_large_files_to_memory">Don’t add large files to memory</h3>
<p>This one is obvious and well known. If you have large files to process, for example a large CSV file, read it line-by-line and process in little chunks instead of loading the entire file to memory. There are rather rare cases where a single line of csv would be larger than 1mb, thus allowing you to fit it in New Space.</p>
<h3 id="Do_not_block_main_server_thread">Do not block main server thread</h3>
<p>If you have some hot API which takes some time to process, such as an API to resize images, move it to a separate thread or turn it into a background job. CPU intensive operations would block main thread forcing all other customers to wait and keep sending requests. Unprocessed request data would stack in memory, thus forcing full GC to take longer time to finish.</p>
<h3 id="Do_not_create_unnecessary_data">Do not create unnecessary data</h3>
<p>I once had a weird experience with restify. If you send a few hundred thousand requests to an invalid URL then the application memory would rapidly grow on up to hundred megabytes until a full GC kicks in a few seconds later, which is when everything would go back to normal. Turns out that for each invalid URL, restify generates a new error object which includes long stack traces. This forced newly created objects to be allocated in Large Object Space rather than in New Space.</p>
<p>Having access to such data could be very helpful during development, but obviously not required on production. Therefore the rule is simple - do not generate data unless you certainly need it.</p>
<h3 id="Know_your_tools">Know your tools</h3>
<p>Last, but certainly not the least, is to know your tools. There are various debuggers, leak cathers, and usage graphs generators. All those tools can help you make your software faster and more efficient.</p>
<h3 id="Conclusion">Conclusion</h3>
<p>Understanding how V8’s garbage collection and code optimizer works is a key to application performance. V8 compiles JavaScript to native assembly and in some cases well written code could achieve performance comparable with GCC compiled applications.</p>
<p>And in case you are wondering, the new API application for my Toptal client, although there is room for improvement, is working very well!</p>
<p>Joyent recently released a new version of Node.js which uses one of the latest versions of V8. Some applications written for Node.js v0.12.x may not be compatible with the new v4.x release. However, applications will experience tremendous performance and memory usage improvement within the new version of Node.js.</p>

      
    </div>
    
    <footer>
      <div class="alignleft">
      
      
      </div>
      <div class="clearfix"></div>
    </footer>
    
  </div>
</article>


<section id="comment">
  
            <!-- Duoshuo Comment BEGIN -->
            <div class="ds-thread"></div>
            <script type="text/javascript">
                var duoshuoQuery = {short_name:"uupup"};
                (function() {
                    var ds = document.createElement('script');
                    ds.type = 'text/javascript';ds.async = true;
                    ds.src = 'http://static.duoshuo.com/embed.js';
                    ds.charset = 'UTF-8';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
            </script>
            <!-- Duoshuo Comment END -->
      
  
</section>

</div></div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="inner"><div class="alignleft">
  <p>
  
    &copy; 2015 H1bomb
  
  </p>
  <p>
    <a href="http://github.com/willerce/hexo-theme-noderce">Noderce</a> Theme By <a href="http://willerce.com" >willerce</a>
  </p>

</div>
<div class="clearfix"></div></div></footer>
  <script type="text/javascript">

</script>

</body>
</html>
