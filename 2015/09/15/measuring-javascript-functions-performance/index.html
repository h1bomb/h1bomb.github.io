<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>uupup！ › 测量javascript函数的性能[译]</title>
  <meta name="author" content="H1bomb">
  
  <meta name="description" content="原地址:http://www.sitepoint.com/measuring-javascript-functions-performance
性能总是软件中扮演了重要的角色。在网络上，性能是尤为重要，如果我们提供缓慢的网页给用户，我们的用户可以轻松更改网站去访问我们的竞争对手的网站。作为一个专业的">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="测量javascript函数的性能[译]"/>
  <meta property="og:site_name" content="uupup！"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="uupup！" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-63097959-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">uupup！</a></h1>
  <h2><a href="/"></a></h2>
  <nav id="main-nav">
    <ul>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">测量javascript函数的性能[译]</h1>
  

      
      <time datetime="2015-09-15T00:48:21.000Z">Sep 15 2015</time>
      
    </header>
    <div class="entry">
      
        <p>原地址:<a href="http://www.sitepoint.com/measuring-javascript-functions-performance/" target="_blank" rel="external">http://www.sitepoint.com/measuring-javascript-functions-performance</a></p>
<p>性能总是软件中扮演了重要的角色。在网络上，性能是尤为重要，如果我们提供缓慢的网页给用户，我们的用户可以轻松更改网站去访问我们的竞争对手的网站。作为一个专业的web开发者，我们不得不把这个问题考虑在内。很多老的网络性能优化的最佳实践，就像请求最小化，使用CDN，不写渲染代码块，如今还是管用的。然而，越来越多的web应用在使用Javascript，验证我们的代码是快的是很重要的。</p>
<p>假如你有一个正在运行的函数，但是你怀疑这个函数运行没有足够快，同时你计划着要改进这个函数。如何证明你的假设呢？什么是当今测试函数性能的最贱实践呢？一般来说，最好实现这个任务的方式是使用函数内建的<code>performance.now()</code>来测量在你执行函数前后的时间。</p>
<p>在这篇文章我们将会讨论如何测量代码执行时间和避免一些常见的坑的技术。</p>
<p><code>Performance.now()</code><br>高精度计时接口提供的一个方法，名字叫<code>now()</code>的可以返回一个DOM高精度时间戳对象。提供了一个浮点小数反映当前时间毫秒到毫秒的千分之一的时间戳。分别，这些数据没有添加过多的值来提供你分析，但是两个不同的数字之间的差值可以描述所消耗多少时间。</p>
<p>In addition to the fact that it is more accurate than the built-in Date object, it’s also “monotonic”. That means, in simple terms, that it’s not affected by the system (e.g. your laptop OS) periodically correcting the system time. In even simpler terms, defining two instances of Date and calculating the difference isn’t representative of the time that has passed.</p>
<p>The mathematical definition of “monotonic” is (of a function or quantity) varying in such a way that it either never decreases or never increases.</p>
<p>Another way of explaining it, is by trying to imagine using it around the times of the year when the clocks go forward or go back. For example, when the clocks in your country all agree to skip an hour for the sake of maximizing daytime sunshine. If you were to make a Date instance before clocks go back an hour, and another Date instance afterwards, looking at the difference it would say something like “1 hour and 3 seconds and 123 milliseconds”. With two instances of performance.now() the difference would be “3 seconds 123 milliseconds and 456789 thousands of a millisecond”.</p>
<p>In this section, I won’t cover this API in detail. So if you want to learn more about it and see some example of its use, I suggest you to read the article Discovering the High Resolution Time API.</p>
<p>Now that you know what the High Resolution Time API is and how to use it, let’s delve into some potential pitfalls. But before doing so, let’s define a function called makeHash() that we’ll use for the remainder of the article.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHash</span><span class="params">(source)</span> </span>{</div><div class="line">  <span class="keyword">var</span> hash = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (source.length === <span class="number">0</span>) <span class="keyword">return</span> hash;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; source.length; i++) {</div><div class="line">    <span class="keyword">var</span> char = source.charCodeAt(i);</div><div class="line">    hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</div><div class="line">    hash = hash & hash; <span class="comment">// Convert to 32bit integer</span></div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> hash;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>The execution of such function can be measured as shown below:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t0 = performance.now();</div><div class="line"><span class="keyword">var</span> result = makeHash(<span class="string">'Peter'</span>);</div><div class="line"><span class="keyword">var</span> t1 = performance.now();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Took'</span>, (t1 - t0).toFixed(<span class="number">4</span>), <span class="string">'milliseconds to generate:'</span>, result);</div></pre></td></tr></table></figure>

<p>If you run this code in a browser, you should see something like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Took <span class="number">0.2730</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div></pre></td></tr></table></figure>

<p>live demo of this code is shown below:</p>
<p>See the Pen YXmdNJ by SitePoint (@SitePoint) on CodePen.</p>
<p>With this example in mind, let’s start our discussion.</p>
<p>Pitfall #1 – Accidentally Measuring Unimportant Things<br>In the example above, you can note that the only thing that we do between one performance.now() and the other is calling the function makeHash() and assigning its value to a variable result. This gives us the time it takes to execute that function and nothing else. This measurement could also be made as detailed below:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t0 = performance.now();</div><div class="line"><span class="built_in">console</span>.log(makeHash(<span class="string">'Peter'</span>));  <span class="comment">// bad idea!</span></div><div class="line"><span class="keyword">var</span> t1 = performance.now();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Took'</span>, (t1 - t0).toFixed(<span class="number">4</span>), <span class="string">'milliseconds'</span>);</div></pre></td></tr></table></figure>

<p>A live demo of this snippet is shown below:</p>
<p>See the Pen PqMXWv by SitePoint (@SitePoint) on CodePen.</p>
<p>But in this case, we would be measuring the time it takes to call the function makeHash(‘Peter’) and how long it takes to send and print that output on the console. We don’t know how long each of those two operations took. You only know the combined time. Also, the time it takes to send and print the output will vary greatly depending on the browser and even on what’s going on in it at that time.</p>
<p>Perhaps you’re perfectly aware that console.log is unpredictably slow. But it would be equally wrong to execute more than one function, even if each function does not involve any I/O. For example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t0 = performance.now();</div><div class="line"><span class="keyword">var</span> name = <span class="string">'Peter'</span>;</div><div class="line"><span class="keyword">var</span> result = makeHash(name.toLowerCase()).toString();</div><div class="line"><span class="keyword">var</span> t1 = performance.now();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Took'</span>, (t1 - t0).toFixed(<span class="number">4</span>), <span class="string">'milliseconds to generate:'</span>, result);</div></pre></td></tr></table></figure>

<p>Again, we won’t know how the execution time was distributed. Was it the variable assignment, the <code>toLowerCase()</code> call, or the <code>toString()</code> call?</p>
<p>Pitfall #2 – Measuring only Once<br>Another common mistake is to make just one measurement, summarize the time taken and draw conclusions based on that. It’s likely to be totally different at different times. The execution time greatly depends on various factors:</p>
<p>Time for the compiler to warm up (e.g. time to compile the code into byte code)<br>The main thread being busy doing other things we didn’t realize were going on<br>Your computer’s CPU(s) being busy with something that slows down your whole browser<br>An incremental improvement is to execute the function repeatedly, like this:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t0 = performance.now();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">  makeHash(<span class="string">'Peter'</span>);</div><div class="line">}</div><div class="line"><span class="keyword">var</span> t1 = performance.now();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Took'</span>, ((t1 - t0) / <span class="number">10</span>).toFixed(<span class="number">4</span>), <span class="string">'milliseconds to generate'</span>);</div></pre></td></tr></table></figure>

<p>A live demo of this example is shown below:</p>
<p>See the Pen Qbezpj by SitePoint (@SitePoint) on CodePen.</p>
<p>The risk with this approach is that our browser’s JavaScript engine might make sub-optimizations which means that the second time the function is called with the same input, it can benefit from remembering the first output and simply use that again. To solve this issue, you can use many different input strings instead of repeatedly sending in the same input string (e.g. ‘Peter’). Obviously, the problem with testing with different inputs is that naturally the function we’re measuring takes different amounts of time. Perhaps some of the inputs cause longer execution time than others.</p>
<p>Pitfall #3 – Relying too Much on the Average<br>In the last section we learned that it’s a good practice to run something repeatedly, ideally with different inputs. However, we have to remember that the problem with different inputs is that the execution might take much longer than all the other inputs. So let’s take a step back and send in the same input. Suppose that we send in the same input ten times and for each, print out how long that took. The output might look something like this:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Took <span class="number">0.2730</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0234</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0200</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0281</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0162</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0245</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0677</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0289</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0240</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div><div class="line">Took <span class="number">0.0311</span> <span class="built_in">milliseconds</span> <span class="built_in">to</span> generate: <span class="number">77005292</span></div></pre></td></tr></table></figure>

<p>Note how the very first time, the number is totally different from the other nine times. Most likely, that’s because the JavaScript engine in our browser makes some sub-optimizations and needs some warm-up. There’s little we can do to avoid that but there are some good remedies we can consider to prevent a faulty conclusion.</p>
<p>One way is to calculate the average of the last nine times. Another more practical way is to collect all results and calculate a median. Basically, it’s all the results lined up, sorted in order and picking the middle one. This is where performance.now() is so useful, because you get a number you can do whatever with.</p>
<p>Let’s try again but this time we’ll use a median function:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">  <span class="keyword">var</span> t0 = performance.now();</div><div class="line">  makeHash(<span class="string">'Peter'</span>);</div><div class="line">  <span class="keyword">var</span> t1 = performance.now();</div><div class="line">  numbers.push(t1 - t0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">median</span><span class="params">(sequence)</span> </span>{</div><div class="line">  sequence.sort();  <span class="comment">// note that direction doesn't matter</span></div><div class="line">  <span class="keyword">return</span> sequence[<span class="built_in">Math</span>.ceil(sequence.length / <span class="number">2</span>)];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Median time'</span>, median(numbers).toFixed(<span class="number">4</span>), <span class="string">'milliseconds'</span>);</div></pre></td></tr></table></figure>

<p>Pitfall #4 – Comparing Functions in a Predictable Order<br>We’ve understood that it’s always a good idea to measure something many times and take the average. Moreover, the last example taught us that it’s preferable to use the median instead of the average.</p>
<p>Now, realistically, a good use of measuring function execution time is to learn which of several functions is faster. Suppose we have two functions that take the same type of input and yield the same result but internally they work differently.</p>
<p>Let’s say we want to have a function that returns true or false if a certain string is in an array of other strings, but does this case insensitively. In other words we can’t use Array.prototype.indexOf because it’s not case insensitive. Here’s one such implementation:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIn</span><span class="params">(haystack, needle)</span> </span>{</div><div class="line">  <span class="keyword">var</span> found = <span class="literal">false</span>;</div><div class="line">  haystack.forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (element.toLowerCase() === needle.toLowerCase()) {</div><div class="line">      found = <span class="literal">true</span>;</div><div class="line">    }</div><div class="line">  });</div><div class="line">  <span class="keyword">return</span> found;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isIn([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'B'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIn([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'d'</span>));  <span class="comment">// false</span></div></pre></td></tr></table></figure>

<p>Immediately we notice that this can be improved because the haystack.forEach loop always goes through all the elements even if we have an early match. Let’s try to write a better version using a good old for loop.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIn</span><span class="params">(haystack, needle)</span> </span>{</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = haystack.length; i &lt; len; i++) {</div><div class="line">    <span class="keyword">if</span> (haystack[i].toLowerCase() === needle.toLowerCase()) {</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isIn([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'B'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIn([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'d'</span>));  <span class="comment">// false</span></div></pre></td></tr></table></figure>

<p>Now let’s see which one is the fastest. We do this by running each function 10 times and collecting all the measurements:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIn1</span><span class="params">(haystack, needle)</span> </span>{</div><div class="line">  <span class="keyword">var</span> found = <span class="literal">false</span>;</div><div class="line">  haystack.forEach(<span class="function"><span class="keyword">function</span><span class="params">(element)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (element.toLowerCase() === needle.toLowerCase()) {</div><div class="line">      found = <span class="literal">true</span>;</div><div class="line">    }</div><div class="line">  });</div><div class="line">  <span class="keyword">return</span> found;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIn2</span><span class="params">(haystack, needle)</span> </span>{</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = haystack.length; i &lt; len; i++) {</div><div class="line">    <span class="keyword">if</span> (haystack[i].toLowerCase() === needle.toLowerCase()) {</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(isIn1([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'B'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIn1([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'d'</span>));  <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(isIn2([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'B'</span>));  <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIn2([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>], <span class="string">'d'</span>));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">median</span><span class="params">(sequence)</span> </span>{</div><div class="line">  sequence.sort();  <span class="comment">// note that direction doesn't matter</span></div><div class="line">  <span class="keyword">return</span> sequence[<span class="built_in">Math</span>.ceil(sequence.length / <span class="number">2</span>)];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">measureFunction</span><span class="params">(func)</span> </span>{</div><div class="line">  <span class="keyword">var</span> letters = <span class="string">'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z'</span>.split(<span class="string">','</span>);</div><div class="line">  <span class="keyword">var</span> numbers = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; letters.length; i++) {</div><div class="line">    <span class="keyword">var</span> t0 = performance.now();</div><div class="line">    func(letters, letters[i]);</div><div class="line">    <span class="keyword">var</span> t1 = performance.now();</div><div class="line">    numbers.push(t1 - t0);</div><div class="line">  }</div><div class="line">  <span class="built_in">console</span>.log(func.name, <span class="string">'took'</span>, median(numbers).toFixed(<span class="number">4</span>));</div><div class="line">}</div><div class="line"></div><div class="line">measureFunction(isIn1);</div><div class="line">measureFunction(isIn2);</div></pre></td></tr></table></figure>

<p>We run that and get following output:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line"><span class="literal">true</span></div><div class="line"><span class="literal">false</span></div><div class="line">isIn1 took <span class="number">0.0050</span></div><div class="line">isIn2 took <span class="number">0.0150</span></div></pre></td></tr></table></figure>

<p>A live demo of this example is shown below:</p>
<p>See the Pen YXmdZJ by SitePoint (@SitePoint) on CodePen.</p>
<p>What the heck has just happened? The first function was three times faster. That was not supposed to happen!</p>
<p>The explanation is simple but subtle. The first function which uses haystack.forEach benefits from some low-level optimizations in the browser’s JavaScript engine that we don’t get when we use an array index technique. It proves our point: you never know until you measure it!</p>
<p>Conclusions<br>In our attempt to demonstrate how to use performance.now() to get an accurate execution time in JavaScript, we stumbled across a benchmarking scenario where our intuition turned out to be quite the opposite of what our empirical results conclude. The point is that, if you want to write faster web apps your JavaScript code needs to be optimized. Because computers are (almost) living breathing things, they are unpredictable and surprising. The most reliable way to know that our code improvements yield faster execution, is to measure and compare.</p>
<p>The other reason we never know which code is faster, if we have multiple ways of doing the same thing, is because context matters. In the previous section we perform a case insensitive string search looking for one string among 26 other strings. It’s likely that the conclusion would be totally different if we instead had to look for one string among 100,000 other strings.</p>
<p>The list above isn’t exhaustive as there are more pitfalls to be aware of. For example, measuring unrealistic scenarios or only measuring on one JavaScript engine. But the sure thing is that a great asset for JavaScript developers who want to write faster and better web apps is performance.now(). Last but not least, remember that measuring execution time only yields one dimension of “better code”. There’s also memory and code complexity considerations to bear in mind.</p>
<p>What about you? Have you ever used this function to test your code’s performance? If not, how do you proceed in this stage? Please share your thoughts in the comments below. Let’s start a discussion!</p>

      
    </div>
    
    <footer>
      <div class="alignleft">
      
      
      </div>
      <div class="clearfix"></div>
    </footer>
    
  </div>
</article>


<section id="comment">
  
            <!-- Duoshuo Comment BEGIN -->
            <div class="ds-thread"></div>
            <script type="text/javascript">
                var duoshuoQuery = {short_name:"uupup"};
                (function() {
                    var ds = document.createElement('script');
                    ds.type = 'text/javascript';ds.async = true;
                    ds.src = 'http://static.duoshuo.com/embed.js';
                    ds.charset = 'UTF-8';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
            </script>
            <!-- Duoshuo Comment END -->
      
  
</section>

</div></div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="inner"><div class="alignleft">
  <p>
  
    &copy; 2015 H1bomb
  
  </p>
  <p>
    <a href="http://github.com/willerce/hexo-theme-noderce">Noderce</a> Theme By <a href="http://willerce.com" >willerce</a>
  </p>

</div>
<div class="clearfix"></div></div></footer>
  <script type="text/javascript">

</script>

</body>
</html>
