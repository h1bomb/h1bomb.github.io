<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>uupup！ › archive_b</title>
  <meta name="author" content="H1bomb">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="uupup！"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="uupup！" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-63097959-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">uupup！</a></h1>
  <h2><a href="/"></a></h2>
  <nav id="main-nav">
    <ul>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2015</h2>


<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/09/05/40-npm-modules-we-can-t-live-without/">40个我们不可或缺的NPM包[译]</a></h1>
  

      
      <time datetime="2015-09-05T15:41:06.000Z">Sep 5 2015</time>
      
    </header>
    <div class="entry">
      
        <p>原地址：<a href="https://medium.com/startup-study-group/40-npm-modules-we-can-t-live-without-36e29e352e3a" target="_blank" rel="external">https://medium.com/startup-study-group/40-npm-modules-we-can-t-live-without-36e29e352e3a</a></p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/800/1*Cv7F9UtBMhsrcV2_rwqEgA.png" alt="npm picture"></p>
<p>Croissant按照字母顺序分享了他们用到的40个不可或缺的NPM模块：</p>
<p>agenda</p>
<p>这是一个类似于“cron”的作业，如每隔几分钟做一些事情。</p>
<p>agenda-ui</p>
<p>可视化的界面，用于管理agenda的作业，就像麦当劳的订单界面，让员工知道订单的状态。</p>
<p>async</p>
<p>用于对多个异步一次处理，主要用于异步编程，尽管我们也开始迁移到”q”,但是我们任然在一些地方使用，像“waterfall”和“each”对于一行数据在多数据相互依赖操作，会用到。</p>
<p>aws-sdk</p>
<p>我们用于上传文件到AWS S3上。</p>
<p>bcryptjs</p>
<p>担心你的密码的安全性？不用了！该算法是行业标准。即使我们遭受过黑客攻击，您的密码将仍然只是字母和符号混合的字符串。只要你的密码不是一个简单字典中的单词，虽然，因为如果有人没有得到这个数据，他们可以尝试在字典中的所有单词进行暴力破解。</p>
<p>body-parser</p>
<p>我们使用ExpressJS，所以我们需要序列化那些JSON的响应。</p>
<p>braintree</p>
<p>用于支付的一个智能（支付网关）依赖包。（国内用到不多）</p>
<p>chai</p>
<p>我们使用这个在我们的集成测试。一个断言库</p>
<p>compression</p>
<p>This is another one of those Express things that you just need. It compresses server responses so the data travels faster across the internet. That’s about it. Good stuff.</p>
<p>express</p>
<p>This one is the big kahuna. This is the core module for the ExpressJS NodeJS web server, which saves us from having to write a ton of boilerplate HTTP server code. It comes with some cool features, such as the ability to specify a static files folder which acts as a simple file server, and of course the ability to easily drop in one of the many plugins created from its vibrant community.</p>
<p>forever</p>
<p>Ever have a node process or express server that crashed? This puppy will start her back up for you. It’s pretty smart too — you can specify how long the process needs to be running before it failed, for the restart to occur. This prevents an auto-failing process from being restarted over and over again.</p>
<p>fs-extra</p>
<p>When the “fs” module is just not enough, “fs-extra” gives you all that and more. We really just use it for its capability to make a nested folder if the parent folder didn’t exist. For some reason, that’s too much to ask for the “fs” folks.</p>
<p>gm</p>
<p>This module is wizardry. GraphicsMagick is a wrapper for the long-lived ImageMagick C library that has been used through the ages by many an image manipulator. We use this to resize and crop our image uploads. You know all those beautiful venue images that we put on AWS? We used this on them first.</p>
<p>gulp</p>
<p>Gulp is always running in the background while we code. It automatically compresses our javascript and css files. We also use it to spawn our test runners. It has tons of packages (which you’re about to find out about)! Some people say it’s like “grunt”, but with streams.</p>
<p>gulp-angular-templatecache</p>
<p>Did we mention we use Angular? We use Angular. This gulp plugin allows us to smush together all our html templates into one file for a quicker load time on the website. Angular can then use this template to load the pages.</p>
<p>gulp-concat</p>
<p>Remember that smushing thing we talked about earlier? This takes care of that.</p>
<p>gulp-csso</p>
<p>Remember how we like smushing things? This lets us smush things into even smaller files by first minifying the css files that are about to be smushed.</p>
<p>gulp-istanbul</p>
<p>Gulp is also a great test runner, runner. While running tests, “istanbul” will output a report showing our unit and integration test coverage, with percentages showing how much code was covered in the test. Magical.</p>
<p>gulp-livereload</p>
<p>A must for front-end developers, this connects to your web browser and refreshes it every time you make a change to an html file. Good job, gulp.</p>
<p>gulp-mocha</p>
<p>More test stuff. This is just a wrapper for mocha, which we use for integration tests, such as making sure an API endpoint works as expected.</p>
<p>gulp-plumber</p>
<p>Because of all our streaming and piping with gulp, we need this little library. In case something like gulp-csso fails, this will keep things running smoothly.</p>
<p>gulp-sass</p>
<p>You thought we use CSS? Think again. Everything you see was once a young, budding, scss (a.k.a. Sass) file. Gulp watches and compiles our master css output every time we make a change.. super quick!</p>
<p>gulp-uglify</p>
<p>Last but not least, this gulp plugin does good ol’ uglification of front end JavaScript code so we can send it to you super fast and super securely.</p>
<p>jwt-simple</p>
<p>Back to reality, away from the gulpies, next we have the package that makes authorization easy. When you log in to Croissant, we take your information and smush it all together and encode it with jwt-simple and tell your browser what came out. Then, your browser uses the token we gave you each time it does something that requires you to be logged in.</p>
<p>lodash</p>
<p>Lodash embodies winning at life. All the stuff you ever needed for working with collections of objects and arrays in JavaScript all in one simple library. We are big fans of pick, omit, and contains — useful for limiting API server responses for quicker load times.</p>
<p>mime-types</p>
<p>We run a tight ship here at Croissant, and that means keeping track of the file types that we upload to AWS S3. One trick to doing this is taking the file extension and feeding it into this library, resulting in something like “image/jpeg” for a jpg file.</p>
<p>mocha</p>
<p>With this, all we need to do is type “mocha” and it runs a plethora of tests that we drew up using the “describe” and “it” functions for organizing tests. It doesn’t get much simpler than this for running JavaScript tests.</p>
<p>moment</p>
<p>Everyone who has ever programmed in anything has run into dealing with dates and times. JavaScript by itself is very basic, but moment makes it all better. With moment, you just pass in the raw JavaScript date object, and in return, you get a nice little ball of date and time functionality that you can play with, such as formatting, adding time, and altering.</p>
<p>moment-timezone</p>
<p>Don’t fall into the trap of forgetting about timezones though. If you’re not careful, someone on the other side of the world will think your store opens at 3 am instead of noon. This package is useful in converting our UTC server times into the timezone of the venue, so you know when to show up, no matter where you are in the world.</p>
<p>mongoose</p>
<p>Did we mention we use MongoDB? We use MongoDB. Mongoose keeps our team in the know, allowing us to always see at a glance what the structure of our data is. Without it, you might end up with all sorts of objects in the database, causing who knows what kind of chaos on the back and front ends.</p>
<p>morgan</p>
<p>Just like body-parser, this is another one of those packages that you simply cannot do without when running an Express server. Not only does it output all sorts of info, such as response time and path name whenever there is an HTTP request, but it also lets you customize (using a function!) what you want to see in the output.</p>
<p>newrelic</p>
<p>New Relic is a cool company that gives you info about your app. You simply add the package to the first line of code in your server, and then go onto their website to watch the magic happen. We use it to get notified if there are a bunch of errors happening on our server in production.</p>
<p>nodemailer</p>
<p>If you ever need to send email, don’t send it yourself — use a transactional email service, such as SendGrid. It comes with some great features, such as the ability to make a nice template that wraps all of our emails. Nodemailer is the package that lets us send simple messages to SendGrid.</p>
<p>prerender-node</p>
<p>Remember that Angular thing we use? It sucks for SEO because most search engines can’t understand it. In comes prerendering to the rescue. With it, web crawlers can easily see a non-Angular version of your website because the prerenderer estimated what it looks like. Turn off JavaScript in your web browser next time you browse Croissant and you’ll see what we mean.</p>
<p>protractor</p>
<p>Anyone who has ever worked with webdriver for automating browser tasks and tests, will quickly see the value in having an Angular wrapper. This wrapper waits for Angular to load on the page and waits for any promises to resolve before going to the next line of tests. This is handy for our app which is rich in asynchronous events.</p>
<p>q</p>
<p>While async is good for waterfalls and map operations, “q” is great for making promises. By that, we mean taking a normal callback function and wrapping it up in the “q” promise syntax. This lets us make promise chains involving asynchronous functions that normally use callbacks, a.k.a. callback hell.</p>
<p>request</p>
<p>Every once in a while we need to make a manual HTTP request to an external server. We’ve always stuck to using this package for doing this kind of task since the dawn of NodeJS. Mostly however, the sdk’s for the external services we use do this for us, using “request” under the hood.</p>
<p>slug</p>
<p>This is the library that turns “Hello There” into “hello-there”, perfect for making dynamic titles into URL-friendly links. We use this for taking the names of our venues and making that unique link that you can share with your buddies so they know where to find you.</p>
<p>stripe</p>
<p>Time to get paid. Stripe is our payment processor for credit cards. They’re nice enough to store customer credit card information in a PCI-compliant way so we don’t have to. We use their sdk to put cards on file and make charges.</p>
<p>supertest-as-promised</p>
<p>This is the core of our integration tests. Using promises we can easily expect a certain response status code, while also using the response data in the next step of the test. We use this with chai.</p>
<p>Welp, there you have it folks. Our list of goodies. We’re always open to questions, comments, and suggestions. Please be gentle :)</p>
<p>Dave<br>Co-founder &amp; CEO, Croissant</p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/09/03/Co-Generator-Usage/">Generator库：co的用法</a></h1>
  

      
      <time datetime="2015-09-03T09:41:11.000Z">Sep 3 2015</time>
      
    </header>
    <div class="entry">
      
        <p>什么是Generator？</p>
<p>Generator是ES6里面新增的语法特性，是异步编程的一个语法级的解决方案。Generator在内部封装的多个状态，在执行Generator函数的时候，会返回一个遍历状态的迭代器对象。表现形式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span><span class="params">()</span> </span>{  <span class="comment">//*是Generator一个语法表示</span></div><div class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;<span class="comment">//yield 是返回状态的值</span></div><div class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</div><div class="line"></div><div class="line"></div><div class="line">hw.next();  <span class="comment">//在每次执行迭代器对象时，会返回当前获取的状态信息。</span></div><div class="line"><span class="comment">// { value: 'hello', done: false }</span></div><div class="line"></div><div class="line">hw.next();</div><div class="line"><span class="comment">// { value: 'world', done: false }</span></div><div class="line"></div><div class="line">hw.next();</div><div class="line"><span class="comment">// { value: 'ending', done: true }</span></div><div class="line"></div><div class="line">hw.next();</div><div class="line"><span class="comment">// { value: undefined, done: true }</span></div></pre></td></tr></table></figure>

<blockquote>
<p>Generator与协程<br>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>
<p>（1）协程与子例程的差异</p>
<p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>
<p>（2）协程与普通线程的差异</p>
<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>
<p>由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>
<p>Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<p>如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p>
</blockquote>
<p>co是什么？</p>
<p>co是tj写的一个用于 Generator 函数的自动执行的函数库。最新是4.0版本，支持promise等一些新特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> *<span class="params">()</span></span>{</div><div class="line">  <span class="comment">// yield any promise</span></div><div class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> Promise.resolve(<span class="literal">true</span>);</div><div class="line">}).catch(onerror);</div><div class="line"></div><div class="line">co(<span class="function"><span class="keyword">function</span> *<span class="params">()</span></span>{</div><div class="line">  <span class="comment">// resolve multiple promises in parallel</span></div><div class="line">  <span class="keyword">var</span> a = Promise.resolve(<span class="number">1</span>);</div><div class="line">  <span class="keyword">var</span> b = Promise.resolve(<span class="number">2</span>);</div><div class="line">  <span class="keyword">var</span> c = Promise.resolve(<span class="number">3</span>);</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [a, b, c];</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">  <span class="comment">// =&gt; [1, 2, 3]</span></div><div class="line">}).catch(onerror);</div><div class="line"></div><div class="line"><span class="comment">// errors can be try/catched</span></div><div class="line">co(<span class="function"><span class="keyword">function</span> *<span class="params">()</span></span>{</div><div class="line">  <span class="keyword">try</span> {</div><div class="line">    <span class="keyword">yield</span> Promise.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>));</div><div class="line">  } <span class="keyword">catch</span> (err) {</div><div class="line">    <span class="built_in">console</span>.error(err.message); <span class="comment">// "boom"</span></div><div class="line"> }</div><div class="line">}).catch(onerror);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onerror</span><span class="params">(err)</span> </span>{</div><div class="line">  <span class="comment">// log any uncaught errors</span></div><div class="line">  <span class="comment">// co will not throw any errors you do not handle!!!</span></div><div class="line">  <span class="comment">// HANDLE ALL YOUR ERRORS!!!</span></div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>数组方式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</div><div class="line">    Promise.resolve(<span class="number">1</span>),</div><div class="line">    Promise.resolve(<span class="number">2</span>),</div><div class="line">    Promise.resolve(<span class="number">3</span>),</div><div class="line">  ];</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; [1, 2, 3]</span></div><div class="line">}).catch(onerror);</div></pre></td></tr></table></figure>

<p>对象方式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> {</div><div class="line">    <span class="number">1</span>: Promise.resolve(<span class="number">1</span>),</div><div class="line">    <span class="number">2</span>: Promise.resolve(<span class="number">2</span>),</div><div class="line">  };</div><div class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// =&gt; { 1: 1, 2: 2 }</span></div><div class="line">}).catch(onerror);</div></pre></td></tr></table></figure>

<p>co(fn*).then( val =&gt; )</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> Promise.resolve(<span class="literal">true</span>);</div><div class="line">}).then(<span class="function"><span class="keyword">function</span> <span class="params">(val)</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(val);</div><div class="line">}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>{</div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>var fn = co.wrap(fn*)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = co.wrap(<span class="function"><span class="keyword">function</span>* <span class="params">(val)</span> </span>{</div><div class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> Promise.resolve(val);</div><div class="line">});</div><div class="line"></div><div class="line">fn(<span class="literal">true</span>).then(<span class="function"><span class="keyword">function</span> <span class="params">(val)</span> </span>{</div><div class="line"></div><div class="line">});</div></pre></td></tr></table></figure>


      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/09/02/Bluebird-Promise-Usage/">Bluebird中Promise模式使用</a></h1>
  

      
      <time datetime="2015-09-02T00:55:32.000Z">Sep 2 2015</time>
      
    </header>
    <div class="entry">
      
        <p><img src="https://camo.githubusercontent.com/f67ead75c0654cefe0c5b791508731cf08cb5b0c/687474703a2f2f7065746b61616e746f6e6f762e6769746875622e696f2f626c7565626972642f6c6f676f2e706e67" alt="bluebird logo"><br>Bluebird是一个高性能全功能的Promise库，主要有以下特性：</p>
<blockquote>
<ul>
<li>实现了Promises A+规范</li>
<li>同步检查(promise状态，返回值，失败原因)</li>
<li>并发调用(调用多个异步处理)</li>
<li>异步模型转化到Promise模式</li>
<li>使用通过并行使用Python/C＃进行资源管理的取消和超时</li>
<li>并行的C#异步和等待</li>
<li>试用的工具方法，如：<br>.bind()<br>.call()<br>Promise.join()…</li>
<li>调试解决方案和合理的默认值</li>
<li>优越的性能表现</li>
</ul>
</blockquote>
<p>bluebird支持node.js和浏览器端</p>
<p>node.js</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span> bluebird</span></div></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Promise = <span class="built_in">require</span>(<span class="string">"bluebird"</span>);</div></pre></td></tr></table></figure>

<p>浏览器端支持（ES5）</p>
<p><img src="https://camo.githubusercontent.com/335f3fdee6026df48a9699235b03cd3e6bf3dba9/68747470733a2f2f73617563656c6162732e636f6d2f62726f777365722d6d61747269782f7065746b615f616e746f6e6f762e737667" alt="浏览器支持"></p>
<p>可见对于IE必须是IE9和以上</p>
<p>用法：</p>
<p>下载：<a href="https://cdn.jsdelivr.net/bluebird/latest/bluebird.js" target="_blank" rel="external">bluebird.js</a>或<a href="https://cdn.jsdelivr.net/bluebird/latest/bluebird.min.js" target="_blank" rel="external">bluebird.min.js</a></p>
<p>以解析一个json文件为例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fs.readFileAsync(<span class="string">"file.json"</span>).then(<span class="built_in">JSON</span>.parse).then(<span class="function"><span class="keyword">function</span><span class="params">(val)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(val.success);</div><div class="line">})</div><div class="line">.catch(<span class="built_in">SyntaxError</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">"invalid json in file"</span>);</div><div class="line">})</div><div class="line">.catch(<span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">"unable to read file"</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>具体需要看详细的可以查看<a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">官方github</a></p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/09/01/JQuery-Deferred-Promise/">JQuery中Deferred/Promise的使用</a></h1>
  

      
      <time datetime="2015-09-01T00:55:27.000Z">Sep 1 2015</time>
      
    </header>
    <div class="entry">
      
        <p>同样Deferred也是为了解决异步嵌套回调而存在的。早在JQuery 1.5就已经支持了。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dtd = $.Deferred(); <span class="comment">// 新建一个Deferred对象</span></div><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span><span class="params">(dtd)</span></span>{</div><div class="line">    <span class="keyword">var</span> tasks = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">　　　　　　alert(<span class="string">"执行完毕！"</span>);</div><div class="line">　　　　　　dtd.resolve(); <span class="comment">// 改变Deferred对象的执行状态</span></div><div class="line">　　　　};</div><div class="line"></div><div class="line">　　　　setTimeout(tasks,<span class="number">5000</span>);</div><div class="line">　　　　<span class="keyword">return</span> dtd.promise(); <span class="comment">// 返回promise对象</span></div><div class="line">　　};</div><div class="line"><span class="keyword">var</span> d = wait(dtd); <span class="comment">// 新建一个d对象，改为对这个对象进行操作</span></div><div class="line">$.when(d)</div><div class="line"> .done(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ alert(<span class="string">"哈哈，成功了！"</span>); })</div><div class="line"> .fail(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ alert(<span class="string">"出错啦！"</span>); });</div></pre></td></tr></table></figure>

<p>我们看下怎么样用，下面列举了几个场景：</p>
<ol>
<li>单个Ajax异步交互</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">'abc.php'</span>).done(<span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>{</div><div class="line">    alert(<span class="string">'success'</span>);</div><div class="line">}).fail(<span class="function"><span class="keyword">function</span> <span class="params">(jqXHR, textStatus, errorThrown)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<ol>
<li>多个Ajax异步交互</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$.when($.ajax(<span class="string">'abc.php'</span>), $.ajax(<span class="string">'abc2.php'</span>), $.ajax(<span class="string">'abc3.php'</span>))</div><div class="line">.done(<span class="function"><span class="keyword">function</span><span class="params">(result1, result2, result3)</span> </span>{</div><div class="line">    alert(<span class="string">'success'</span>);</div><div class="line">}).fail(<span class="function"><span class="keyword">function</span> <span class="params">(jqXHR, textStatus, errorThrown)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>);</div><div class="line">});</div></pre></td></tr></table></figure>

<ol>
<li>动画链式调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.when(preloadImage())</div><div class="line">.then(animation01)</div><div class="line">.then(animation02)</div><div class="line">.then(animation03)</div><div class="line">.then(transition)</div><div class="line">.then(merge)</div><div class="line">.then(zoom)</div><div class="line">.then(showContent)</div><div class="line">.then(flicker);</div></pre></td></tr></table></figure>

<p>和Promise/A+的规范有些出入，可能因为实现比较早，但是其意义和原理是差不多的。</p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/08/30/Promise-Patterns/">promise设计模式</a></h1>
  

      
      <time datetime="2015-08-30T15:48:38.000Z">Aug 30 2015</time>
      
    </header>
    <div class="entry">
      
        <p>promise是为了解决Javascript的异步编程导致的‘callback hell’而存在的。</p>
<p>目前有多种设计方式，比较知名的如：promise/deferred（jquery就使用了这个方式）,<br>promise/a+（是es6 promise规范）。</p>
<p>当然我们还是希望使用原生的Promise对象，先看下浏览器的支持度：</p>
<iframe src="http://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>

<p>可见IE还是重灾区，firefox和chrome很早就已经实现了原生的promise了。当然如果要使用promise，已有不少第三方库的支持，如jquery，Q，Bluebird，Thenjs…<br>还是比较多的实现，同时值得一提的是推荐使用polyfill的方式来解决，如 <a href="https://github.com/jakearchibald/es6-promise" target="_blank" rel="external">es6-promise</a>,或者使用<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>进行es6编译转化也是可以的。</p>
<p>先用一个图说明下什么原理：</p>
<p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt="promise 原理图"></p>
<p>看上去很复杂，其实就是(三个状态的流转)：</p>
<p><img src="http://liubin.github.io/promises-book/Ch1_WhatsPromises/img/promise-states.png" alt="promise 简单图"></p>
<p>分别对应流转，有两个预定义处理句柄：</p>
<p><img src="http://liubin.github.io/promises-book/Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png" alt="Promise 处理图"></p>
<p>以下摘自MDN的Promise/A+规范说明</p>
<blockquote>
<h2 id="属性">属性</h2>
<h3 id="Promise-length">Promise.length</h3>
<p>长度属性，其值为 1 (构造器参数的数目).</p>
<h3 id="Promise-prototype">Promise.prototype</h3>
<p>表示 Promise 构造器的原型.</p>
<h2 id="方法">方法</h2>
<h3 id="Promise-all(iterable)">Promise.all(iterable)</h3>
<p>返回一个promise，当iterable参数里所有的promise都被解决后，该promise也会被解决。</p>
<h3 id="Promise-race(iterable)">Promise.race(iterable)</h3>
<p>返回一个Promise，当iterable参数里的任意一个子Promise被接受或拒绝后，该promise马上也会用子Promise的成功值或失败原因被接受或拒绝。</p>
<h3 id="Promise-reject(reason)">Promise.reject(reason)</h3>
<p>用失败原因reason拒绝一个Promise对象。<br>Promise.resolve(value)<br>用成功值value解决一个Promise对象。如果该value为可继续的（thenable，即带有then方法），返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足（fullfil）返回的Promise对象。</p>
<h2 id="Promise原型">Promise原型</h2>
<h3 id="属性-1">属性</h3>
<h3 id="Promise-prototype-constructor">Promise.prototype.constructor</h3>
<p>返回创建了实例原型的函数.  默认为 Promise 函数.</p>
<h2 id="方法-1">方法</h2>
<h3 id="Promise-prototype-catch(onRejected)">Promise.prototype.catch(onRejected)</h3>
<p>添加一个否定(rejection) 回调到当前 promise, 返回一个新的promise。如果这个回调被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果.</p>
<h3 id="Promise-prototype-then(onFulfilled,_onRejected)">Promise.prototype.then(onFulfilled, onRejected)</h3>
<p>添加肯定和否定回调到当前 promise, 返回一个新的 promise, 将以回调的返回值 来resolve.</p>
</blockquote>
<p>示范代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> </span>{</div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">            resolve(<span class="string">'Async Hello world'</span>);</div><div class="line">        }, <span class="number">16</span>);</div><div class="line">    });</div><div class="line">}</div><div class="line"></div><div class="line">asyncFunction().then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">// =&gt; 'Async Hello world'</span></div><div class="line">}).catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>{</div><div class="line">    <span class="built_in">console</span>.log(error);</div><div class="line">});</div></pre></td></tr></table></figure>

<p>后面再写下在具体开发中如何使用Promise。</p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/08/30/CNUTcon-Participants-Experience/">CNUTCon的参会体验</a></h1>
  

      
      <time datetime="2015-08-30T14:56:46.000Z">Aug 30 2015</time>
      
    </header>
    <div class="entry">
      
        <p>对于容器的了解是从docker开始的（最近一些年docker还是很火的），我对于后端架构以及容器技术属于菜鸟水平，所以此次的体验分享还是注重我个人的理解和想法，大家如果觉得有些理解错误或者粗浅，请谅解。</p>
<p>大体内容可以分为四类：技术前瞻（讲概念），架构体系（讲解决方案），开源项目（设计理念），工具实战（云平台）。干货水货皆有。</p>
<p>一开始主要是redhat的副总裁讲谈下一代的PaaS，中间也介绍了redhat的openshift，以及关于容器安全和标准的一些内容，和容器在Paas中发展重要位置和后续开发模式的转变。由于英语水平有限，所以后续还要关注ppt再研究下，总体还是属于技术前瞻和业界发展的方向性的思索。</p>
<p>后面的CoreOS的演讲者，可能我不专心听吧，像是没有理解什么，发个Slide的<a href="https://github.com/kelseyhightower/cnutcon-2015" target="_blank" rel="external">链接</a>,貌似是一些etcd和Kubernetes的实践。</p>
<p>接下来主要是京东和大众点评的解决方案的分享，感觉像是docker使用的兼容之前虚拟技术的结合的做法，用到了openstack，zookeeper，NATS，以及对于不了解容器方式的开发者兼容模式。使用的规模还是比较大的，同时没有用到mesos，swarm，Kubernetes用于docker的集群管理，而是自己对于docker集群的实现了管理方案。第二天的百度的分享同样自己做了很多的事情，构建自己的云架构。</p>
<p>下午的阿里百川的分享TAE系统，给我的印象，还是比较深的，从技术方向，到架构方向，到实际解决问题，到实现思想，比较开阔和开放的，不光是对于云平台有一定的思想提升，还是对于方法论的提升。直接附上<a href="http://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=209978199&amp;idx=1&amp;sn=2424de46eb7dbe50bcb2b3dd346dbfce&amp;scene=1&amp;srcid=CpLCImrAnW9055VsQGc4" target="_blank" rel="external">链接</a>,非常值得一看。</p>
<p>后来也去听了七牛以及华为的OCT，七牛主要是分享了基于容器技术的数据处理主题，在各种系统资源的调度和解决性能瓶颈，以及利用go的并发优势，充分发挥容器在数据处理微服务的能力。华为的OCT听得比较少，只是对于OTC还是蛮兴趣的，主要用于OCI容器标准化的测试，以及业务测试，性能测试等的测试套件，该项目是开源的，一改我之前对于华为技术封闭的看法。附上<a href="https://github.com/huawei-openlab/oct" target="_blank" rel="external">链接</a>。</p>
<p>由于公司新品节的上线缘故，需要远程支援下，所以第一天晚上的会后活动没有报名参加，因此也不知道会有什么收获，后面关注线上社区看有些什么分享。</p>
<p>第二天，一早，google的美女工程师分享了Kubernetes的设计思想和实践，由于可能她长期在国外工作，演讲基本上50%到60%的英文和剩下的中文，给我在理解上造成了一些障碍，其中对于一些原则，还是记忆犹新，简单大于复杂，宠物VS牲口（pets vs cattle），解释下，什么是宠物和牲口，主要是对于线上的服务的思考，宠物般的服务需要呵护和更多的心智来维护保证高可用，由于维护的成本负担比较重，所以宠物般的服务不会很多，而牲口是则是一群服务，虽然很多，但是不需要给每个牲口做做细心呵护，如果出现问题，简单处理，或者直接杀掉，同样也实现了高可用。Kubernetes就是用于管理容器集群的工具，是google的omega的轻量版本，在开源社区还是比较活跃的，后面我估计也会研究下。</p>
<p>之后去听了一个同样是做容器集群管理的mesos是apache旗下的开源项目，演讲的主题偏于实践，主要是讲如何应用该工具，同样以数人云的实践来讲。有一点的实用价值，中间和旁边的一起听的用友小哥聊了下，他说mesos比起Kubernetes来讲更具有企业实际运用价值，同时也比Kubernetes稳定些。后面有空这两个都可以对比使用下。</p>
<p>下午听了vmware的关于 cloud native app的演讲，结合了vmware的产品讲述了开发栈和运维栈结构异同，以及基于容器的一些好的开发实践，以及对于安全和隔离的vmware的实现方案，说下周一会发布这款产品。</p>
<p>由于定了5点的票，所以只能提前走了，走前听了，daocloud郭总的关于微服务架构演进的演讲，结合自身daocloud项目，讲述了构建微服务的开发过程和架构变迁。可能因为daocloud是创业团队，对于架构变迁都是以快速迭代，需求出发的方式，和我的想法十分对位。也讲了docker在微服务的实现起到的重要作用。其中有一点原则很有意义：如果业务的持续集成的速度和演进的复杂程度出现效率问题，才需要做服务的拆分。关于服务的粒度，也做了和SOA的对比。大体微服务粒度在于5-10个人开发的业务复杂度的粒度。其他由于时间问题，稍微听了下coreos的一个分享，双内核，轻量的Linux系统，用于部署容器的系统，也有一些基于coreos封装的工具。</p>
<p>以上是本次参加全球容器大会的大体体验，总的感觉容器技术，百花齐放，各种实现和解决方案，同时大家对于容器技术很大期望，是未来技术变革的一个基点，但同时，还有不少不足和坑需要大家填补，如安全，隔离性，完善的集群管理，热迁移部署等。</p>
<p>关键字：RedHat openshift vmware OCI coreOS mesos Kubernetes swarm oct omega LXC cgroup</p>
<p>题外话</p>
<p>每次参加技术会议，上厕所都有一个奇怪的现象，男厕所需要方便排队，而女厕所却寥寥无几。<br>妹子出现在会上，十分抢眼。</p>
<p>其他的，后续再整理。</p>
<p>9月29日，回南京的火车上。</p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/05/31/JavaScript-inheritance-5to6/">关于Javascript继承在es5到es6改变</a></h1>
  

      
      <time datetime="2015-05-31T15:02:18.000Z">May 31 2015</time>
      
    </header>
    <div class="entry">
      
        <p>再重温下之前继承的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inherits = <span class="function"><span class="keyword">function</span><span class="params">(ctor, superCtor)</span> </span>{</div><div class="line">  ctor.super_ = superCtor;</div><div class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, {</div><div class="line">    constructor: {</div><div class="line">      value: ctor,</div><div class="line">      enumerable: <span class="literal">false</span>,</div><div class="line">      writable: <span class="literal">true</span>,</div><div class="line">      configurable: <span class="literal">true</span></div><div class="line">    }</div><div class="line">  });</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>{</div><div class="line">  <span class="keyword">this</span>.x = x;</div><div class="line">  <span class="keyword">this</span>.y = y;</div><div class="line">}</div><div class="line"></div><div class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ColorPoint</span><span class="params">(x, y, color)</span> </span>{</div><div class="line"></div><div class="line">  Point.call(<span class="keyword">this</span>, x, y); </div><div class="line">  <span class="keyword">this</span>.color = color;</div><div class="line">}</div><div class="line"></div><div class="line">inherits(ColorPoint, Point);</div><div class="line"></div><div class="line">ColorPoint.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + ColorPoint.super_.prototype.toString.call(<span class="keyword">this</span>); </div><div class="line">}</div></pre></td></tr></table></figure>

<p>然而es6则可以这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Point {</div><div class="line"></div><div class="line">  constructor(x, y) {</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">  }</div><div class="line"></div><div class="line">  toString() {</div><div class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">class</span> ColorPoint extends Point {</div><div class="line"></div><div class="line">  constructor(x, y, color) {</div><div class="line">    super(x, y); </div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  }</div><div class="line"></div><div class="line">  toString() {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + super.toString(); </div><div class="line">  }</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>显然es6的写法更加清晰，隐去了Javascript硬去使用prototype和call的实现细节。但是es6并没有完全按照Java ,C++面向对象的语法来实现，<br>只是对于原型继承的一个语法糖。</p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/05/27/node-inheritance-usage/">nodejs继承的用法</a></h1>
  

      
      <time datetime="2015-05-27T02:28:26.000Z">May 27 2015</time>
      
    </header>
    <div class="entry">
      
        <p>对于<a href="http://h1bomb.github.io/2015/05/22/node-inheritance/" target="_blank" rel="external">上一篇</a>,最后不明白的那块内容，今天在看<code>Object.assign</code>这个Polyfill实现里面有个方法<br><code>defineProperty</code>方法，里面也有</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">    enumerable: <span class="literal">false</span>,</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    writable: <span class="literal">true</span>,</div><div class="line">    value:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{...}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>解释如下：</p>
<blockquote>
<p><strong>configurable</strong></p>
<p>当且仅当这个属性描述符值为 true 时，该属性可能会改变，也可能会被从相应的对象删除。默认为 false。</p>
<p><strong>enumerable</strong></p>
<p>true 当且仅当该属性出现在相应的对象枚举属性中。默认为 false。<br>数据描述符同时具有以下可选键值：</p>
<p><strong>value</strong></p>
<p>与属性相关的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p>
<p><strong>writable</strong></p>
<p>true 当且仅当可能用 赋值运算符 改变与属性相关的值。默认为 false。</p>
</blockquote>
<p>另外,<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">Object.create</a>也有说明，create方法的第二个参数的说明：</p>
<blockquote>
<p><strong>propertiesObject</strong></p>
<p>一个对象值，可以包含若干个属性，属性名为新建对象的属性名，属性值为那个属性的属性描述符对象.</p>
</blockquote>
<p>第一次接触node继承，是在使用<code>events.EventEmitter</code>时接触的。<br>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">"util"</span>);  </div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">"events"</span>);<span class="comment">//EventEmitter通过events模块来访问  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyStream</span><span class="params">()</span> </span>{<span class="comment">//新建一个类  </span></div><div class="line">    events.EventEmitter.call(<span class="keyword">this</span>);  </div><div class="line">}  </div><div class="line">  </div><div class="line">util.inherits(MyStream, events.EventEmitter);</div></pre></td></tr></table></figure>

<p>为什么需要Call父级构造函数呢？inherits方法无法继承父级构造函数的成员方法和变量吗？<br>是的，inherits方法只是把子级的构造函数的原型指向了父级的原型，也就是说，不是父级实例化后的对象<br>所以没有父级构造函数的成员。</p>
<p>这样的好处是继承的方法只是继承了父级在prototype可以共享的方法和属性，降低了原型链的继承查找。<br>call则直接指向了父级构造函数，当实例化子级构造函数时，将父级的构造过程运用于子级。</p>
<p>和之前讲的<a href="http://h1bomb.github.io/2015/05/21/JavaScript-inheritance2/" target="_blank" rel="external">混合方式</a>有点类似，但是从出发点来讲，<br>更清晰的区分了冒充和原型的信息共享。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">123</span>;</div><div class="line">}</div><div class="line"></div><div class="line">A.prototype.say = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</div><div class="line">} </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.b = <span class="number">456</span>;</div><div class="line">}</div><div class="line"></div><div class="line">B.prototype = A.prototype;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b =  <span class="keyword">new</span> B;</div><div class="line"><span class="built_in">console</span>.log(b.say());<span class="comment">//undefined</span></div></pre></td></tr></table></figure>


      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/05/24/node-inheritance/">nodejs继承实现</a></h1>
  

      
      <time datetime="2015-05-24T10:01:51.000Z">May 24 2015</time>
      
    </header>
    <div class="entry">
      
        <p>直接上代码<a href="https://github.com/joyent/node/blob/master/lib/util.js" target="_blank" rel="external">/lib/util.js</a></p>
<p>第634行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">exports.inherits = <span class="function"><span class="keyword">function</span><span class="params">(ctor, superCtor)</span> </span>{</div><div class="line">  ctor.super_ = superCtor;</div><div class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, {</div><div class="line">    constructor: {</div><div class="line">      value: ctor,</div><div class="line">      enumerable: <span class="literal">false</span>,</div><div class="line">      writable: <span class="literal">true</span>,</div><div class="line">      configurable: <span class="literal">true</span></div><div class="line">    }</div><div class="line">  });</div><div class="line">};</div></pre></td></tr></table></figure>

<p>从源码看也是使用原型的方式实现了继承，不过在<code>ctor.super_ = superCtor;</code>里面设置了一个<code>super_</code>的属性指向<br>被继承的构造函数,同时在继承超级构造的原型附加了一些构造的成员属性而创建的对象。</p>
<p>至于constructor里面的这些属性，我目前只能猜猜是用于继承追溯或者构造函数的属性声明。<br>后面详细研究了node的util其他代码或许会有一个明确的答案。</p>

      
    </div>
    
      
    
  </div>
</article>




<article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2015/05/21/JavaScript-inheritance2/">JavaScript的继承之二</a></h1>
  

      
      <time datetime="2015-05-21T00:31:41.000Z">May 21 2015</time>
      
    </header>
    <div class="entry">
      
        <p>继续<a href="http://h1bomb.github.io/2015/05/20/JavaScript-inheritance/" target="_blank" rel="external">上一篇</a>的话题继承，这里主要讲下实际开发的运用。</p>
<h2 id="冒充方式：">冒充方式：</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span><span class="params">(sColor)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.color = sColor;</div><div class="line">    <span class="keyword">this</span>.sayColor = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        alert(<span class="keyword">this</span>.color);</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor)</span> </span>{</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.newMethod = ClassA;</div><div class="line">    <span class="keyword">this</span>.newMethod(sColor);</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.newMethod;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor, sName)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.newMethod = ClassA;</div><div class="line">    <span class="keyword">this</span>.newMethod(sColor);</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.newMethod;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = sName;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA(<span class="string">"blue"</span>);</div><div class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> ClassB(<span class="string">"red"</span>, <span class="string">"John"</span>);</div><div class="line">objA.sayColor();	<span class="comment">//输出 "blue"</span></div><div class="line">objB.sayColor();	<span class="comment">//输出 "red"</span></div><div class="line">objB.sayName();		<span class="comment">//输出 "John"</span></div></pre></td></tr></table></figure>

<p>这种方式同样也可以多重继承，尽管不推崇，但是有一点可以看出这个继承的灵活性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassZ</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.newMethod = ClassX;</div><div class="line">    <span class="keyword">this</span>.newMethod();</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.newMethod;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.newMethod = ClassY;</div><div class="line">    <span class="keyword">this</span>.newMethod();</div><div class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.newMethod;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="call_和_apply方式"><code>call</code> 和 <code>apply</code>方式</h2>
<p>这种方式是利用了<code>this</code>这个关键字，实现的函数成员的复制，同时call和apply也可以利用这个原理实现继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor, sName)</span> </span>{</div><div class="line">    <span class="comment">//this.newMethod = ClassA;</span></div><div class="line">    <span class="comment">//this.newMethod(color);</span></div><div class="line">    <span class="comment">//delete this.newMethod;</span></div><div class="line">    ClassA.call(<span class="keyword">this</span>, sColor);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = sName;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor, sName)</span> </span>{</div><div class="line">    <span class="comment">//this.newMethod = ClassA;</span></div><div class="line">    <span class="comment">//this.newMethod(color);</span></div><div class="line">    <span class="comment">//delete this.newMethod;</span></div><div class="line">    ClassA.apply(<span class="keyword">this</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(sColor));</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = sName;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="prototype方式">prototype方式</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">()</span> </span>{</div><div class="line">}</div><div class="line"></div><div class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</div><div class="line"></div><div class="line">ClassB.prototype.name = <span class="string">""</span>;</div><div class="line">ClassB.prototype.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>原型链是不支持多重继承。记住，原型链会用另一类型的对象重写类的 prototype 属性。</p>
<h2 id="混合方式">混合方式</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span><span class="params">(sColor)</span> </span>{</div><div class="line">    <span class="keyword">this</span>.color = sColor;</div><div class="line">}</div><div class="line"></div><div class="line">ClassA.prototype.sayColor = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    alert(<span class="keyword">this</span>.color);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor, sName)</span> </span>{</div><div class="line">    ClassA.call(<span class="keyword">this</span>, sColor);</div><div class="line">    <span class="keyword">this</span>.name = sName;</div><div class="line">}</div><div class="line"></div><div class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</div><div class="line"></div><div class="line">ClassB.prototype.sayName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>继承机制由<code>ClassA.call(this, sColor);</code>和<br><code>ClassB.prototype = new ClassA();</code>共同作用。<br><code>ClassA.call(this, sColor);</code>在 ClassB 构造函数中，用对象冒充继承 ClassA 类的 sColor 属性。<br><code>ClassB.prototype = new ClassA();</code>用原型链继承 ClassA 类的方法。由于这种混合方式使用了原型链，所以 instanceof 运算符仍能正确运行。</p>
<h2 id="拷贝方式">拷贝方式</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">　<span class="function"><span class="keyword">function</span> <span class="title">extend2</span><span class="params">(Child, Parent)</span> </span>{</div><div class="line">　　　　<span class="keyword">var</span> p = Parent.prototype;</div><div class="line">　　　　<span class="keyword">var</span> c = Child.prototype;</div><div class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</div><div class="line">　　　　　　c[i] = p[i];</div><div class="line">　　　　　　}</div><div class="line">　　　　c.uber = p;</div><div class="line">　　}</div></pre></td></tr></table></figure>

<p>深拷贝(递归拷贝)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span><span class="params">(p, c)</span> </span>{</div><div class="line">　　　　<span class="keyword">var</span> c = c || {};</div><div class="line">　　　　<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> p) {</div><div class="line">　　　　　　<span class="keyword">if</span> (<span class="keyword">typeof</span> p[i] === <span class="string">'object'</span>) {</div><div class="line">　　　　　　　　c[i] = (p[i].constructor === <span class="built_in">Array</span>) ? [] : {};</div><div class="line">　　　　　　　　deepCopy(p[i], c[i]);</div><div class="line">　　　　　　} <span class="keyword">else</span> {</div><div class="line">　　　　　　　　　c[i] = p[i];</div><div class="line">　　　　　　}</div><div class="line">　　　　}</div><div class="line">　　　　<span class="keyword">return</span> c;</div><div class="line">　　}</div></pre></td></tr></table></figure>

<p>jquery就是采用了拷贝的方式。</p>

      
    </div>
    
      
    
  </div>
</article>




<div class="pagination">
  <table width='100%'>
    <tbody>
    <tr>
      <td width='120' align='left'>
        
      </td>
      <td width='auto' align='center'>
          <a href="/archives/">文章归档</a>
      </td>
      <td width='120' align='right'>
        
        <div class="alignright">
          <a href="/archives/2015/page/2/" class="alignright next">next ›</a>
        </div>
        
      </td>
    </tr>
    </tbody>
  </table>
</div>




</div></div>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div class="inner"><div class="alignleft">
  <p>
  
    &copy; 2015 H1bomb
  
  </p>
  <p>
    <a href="http://github.com/willerce/hexo-theme-noderce">Noderce</a> Theme By <a href="http://willerce.com" >willerce</a>
  </p>

</div>
<div class="clearfix"></div></div></footer>
  <script type="text/javascript">

</script>

</body>
</html>
